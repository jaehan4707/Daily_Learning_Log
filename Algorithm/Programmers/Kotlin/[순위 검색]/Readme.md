# 문제 풀이

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTF1sy%2FbtszuEuW9aE%2F5z2hspPKzfMB4YcXTHuCV1%2Fimg.png)
```text
이런 식으로 8개의 조합이 만들어지고, 각각을 적용해보면 32개의 조합이 나올수가 있다. 점수는 무시해서는 안되는 정보이기에, -를 생략한 실제 점수값이 들어가게 될 것이다.

이런식으로 모든 정보와 그에 대응되는 점수값들을 HashMap 형태로 저장한다.

여기서 key는 java, backend, junior, pizza와 같은 정보들이고, value는 key에 해당되는 점수들이다.

이러면 우리는 info에 대응되는 모든 조합과 점수들을 알고 있다.

이렇게 얻은 정보를 바탕으로 쿼리문의 정보와 매칭을 하는 것이다.

쿼리문의 정보와 key를 비교해서, key가 있다면, 해당 쿼리에서 탐색하고자 하는 점수이상인 점수들의 크기를 리턴해주면 된다.

여기서 탐색을 하는 과정에서 이분탐색을 쓰지 않으면 시간초과가 발생한다.

아마 점수집합의 크기가 매우 커서 점수를 하나하나 비교하는 것보단 탐색만을 최적화하는 이분탐색을 사용하는 것이 시간을 줄일 수 있다.

우리는 점수를 찾는 것이 아닌, 쿼리문에 점수 이상인 점수들의 개수를 찾는 것이기 때문에 이분탐색을 사용해서, 시간을 줄일 수 있다.

이번 문제는 배열에서 탐색의 시간을 줄이기 위한 방안으로 이분탐색을 떠올리지 풀수 없는 문제이다.

이분탐색을 사용하지 않더라도, 배열의 탐색을 줄이기 위한 다른방법을 사용해도 상관없지만, 가장 대중적인 방법인 이분탐색을 사용하는 분들이 많았고, 나도 그에 따라서 이분탐색으로 문제를 해결했다.
```