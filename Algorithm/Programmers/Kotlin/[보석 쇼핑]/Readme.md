# 문제 풀이
```text
초기에는 N*N으로 탐색을 해서 요구사항에 맞는 짧은 구간, 길이가 같으면 시작 구간이 더 작은 구간을 함수를 통해서 반환했다.
정확성 테스트는 쉽게 통과했지만, 효율성 테스트에서 시간초과를 만날 수 있었다.
어쩐지 LV3 치고 문제가 너무 쉬웠는데, 아마 배열을 탐색하는 과정에서 N*N 알고리즘을 사용해서 그런 것 같다.
1차원이고, 완전 탐색을 피하기 위한 알고리즘으로 투포인터 알고리즘이 있다는 것을 저번에 공부했고,
투 포인터를 적용해보기로 했다.

우선 입력받은 보석의 배열에서 HashSet을 통해서 중복된 것들을 제외한 유효한 보석들만을 담는다.
이제 이 HashSet은 투 포인터 알고리즘에서 사용될 기준 가방이라고 생각하면 된다.
투포인터는 기본적으로 start와 end를 움직이면서 목표하는 요구사항을 만족하면 start를 한 칸 증가시켜 탐색범위를 감소시킨다.
우리는 보석을 담다가, 만약 기준가방의 보석의 개수와 일치한다면 start를 증가시켜 탐색의 범위를 감소시킬 것이다.

```