# 문제 풀이
아무튼 그럼 우리는 이진트리로 만들지 못하는 경우에 대해서 정리할 수 있다.

부모가 0인데 자식이 1이 포함되어 있는 경우
해당 경우만 제외하면 모두 이진트리로 표현이 가능하다.



이러한 배경지식을 가지고 이제 문제를 풀면 된다.



우선 입력받은 숫자를 2진수로 바꿔줘야 한다.

해당 과정은 2로 계속 나누면서 나머지를 채워주면 될 것이다.

여기서 주의할 점은 해당 과정에서 2진수 배열이 거꾸로 형성되기 때문에, 뒤집어주거나 나중에 작업할 때 계속 뒤집어서 해줘야 한다.

나는 여기서 reversed()를 사용해서 처음부터 뒤집은 2진수 문자열을 반환했다.

그런 다음 포화트리로 만들어줬다.

이진수 문자열의 길이에 따라서 층을 정할 수 있기 때문에 포화트리로 만들어줬다.

당연하게도 남는 자리는 0을 채워야 한다.

앞에서부터 채워줘야 하기에 StringBuilder()를 사용했다.



다음은 이제 이진수 문자열을 트리형태로 쪼개주는 작업이다.

해당 작업은 분할정복으로 해도 되고, 실제 트리를 만들어서 탐색을 진행해도 되지만, 분할정복으로 하는 것이 한 번에 할 수 있기 때문에 그렇게 진행했다.

방법은 간단하다.

1. 문자열을 가운데로 쪼갠다.
2. 여기서 가운데는 root가 되고, 0부터 root-1까지가 왼쪽 서브트리이고, root+1부터 끝까지 오른쪽 서브트리를 형성할 것이다.
3. 그렇다면 왼쪽 서브트리를 다시 재귀함수로 호출하고, 오른쪽 서브트리를 다시 재귀 함수로 호출해서 검사를 진행한다.
4. 재귀함수가 true를 반환하는 조건은 아래와 같다.
   1. 길이가 1일 경우
   2. 1을 포함하지 않는 경우 -> 위에서 설명한 부모가 0이고, 자식이 0인 경우
   3. 루트가 1이고, 왼쪽 서브트리, 오른쪽 서브트리의 결과가 true일 경우
5. 트리를 만들 수 있다면 1이고, 아니라면 0을 넣어준다.