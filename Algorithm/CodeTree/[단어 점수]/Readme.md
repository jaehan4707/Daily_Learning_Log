# 문제 풀이
이번 스프린트에서 정말 어려웠던 문제였다.  
n이 5만이라, n^2 알고리즘을 사용하면 안되는데, 떠오르는 생각이 n^2 밖에 없었다.   
처음엔 이중 포문으로 비교를 했고, 당연하게 시간초과가 발생했다.   
그 이후에는 숫자의 합으로 찾아가기 때문에 map을 사용했다.

```java
HashMap<Long,ArrayList<String>>
```
으로 선언을 해서, 임의의 숫자 number 와 k-number의 key를 찾아서, 문자열을 비교해줬다.   
사실 해당 로직도 시간복잡도가 n^2이다. 

고민을 가진 뒤, map의 자료구조를 조금 수정했다.   
m의 크기가 작은 만큼 카운팅 배열을 쓰면 된다고 생각했고, 알파벳의 종류도 26개이기 때문에
최대 5*26의 배열만 필요하다.

```java
HashMap<Long,int[5][26]> map;
```
위와 같이 선언해서, 각 자리의 알파벳의 개수를 기록한다.   
여기서 주의할 점은 자기 자신까지 검사하는 경우인데, 그럴 경우 m만큼의 점수를 빼주면 된다.
