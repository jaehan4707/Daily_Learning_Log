# 문제 풀이

나는 해당 문제를 전형적인 bfs 문제라고 생각한다. 하지만 bfs 문제에서도 조금 더 진화한 문제이다.

우선 문제 초기에는 DP를 사용해서 주변에 존재하는 쓰레기를 저장해서 방문 처리를 하려고 했지만,

결과적으로 도착지점에 도착한 경우에 최적의 도착을 해야하기 때문에, 도착한 시점에 우리는 가장 적은 쓰레기를 마주치고 밟아야 한다.

그렇기 때문에 DP를 사용하기에는 최적의 도착을 계산할 수 있지만, 최초의 도착이 최적의 도착이라고 장담할 수는 없다.

그렇다면 우리는  다음 방문을 준비할 때 항상 해당 방문이 최적이어야 한다.

따라서 해당 문제는 우선순위 큐를 사용해서 푸는 것이 맞다고 생각한다.


## 정렬 기준
그렇다면 우선순위 큐를 사용한다면 어떠한 기준으로 정렬을 해야 할까?   
문제에서는 가장 적은 쓰레기를 "밟고", 가장 적은 쓰레기 주변을 지나가야 한다.    
따라서 1차적으로 쓰레기를 가장 적게 밟는 것을 기준으로 정렬하고, 그다음으로는 이제 가장 적은 쓰레기 주변을 지나는 것을 기준으로 정렬을 하면 쉽게 풀 수 있을 것이다.    
해당 문제는 왜 PQ를 사용해야 하느냐에 대한 접근이 어려운 문제고, 푸는 것 자체는 어렵지 않다고 생각한다.


나 같은 경우도 문제를 잘못 읽어서 문제를 잘못해석했었다.   

#### 모든 방문에 대해서 주변에 쓰레기가 있는지에 대해서 검사했었다.    

해당 접근 방법은 잘못된 접근 방법이다.    
우선 S와 F 주변에는 쓰레기가 있든지 말든지 계산하지 않는다.    
그리고 방문한 칸이 쓰레기가 있다면 주변에 쓰레기가 있는 것을 신경 쓰지 않는다.    

```
즉 빈칸인 경우에만 주변에 쓰레기가 있는지 검사하는 것이다.
```
#### 주변에 쓰레기를 검사하는 과정에서 주변 모든 쓰레기의 숫자를 더했다.

정말 잘못된 접근 방법이었다.

이제 이동하는 칸이 쓰레기와 인접한 지, 안 한 지를 계산하는 것이라서, 쓰레기가 있다면 +1, 쓰레기가 없다면 +0이지만,    
나는 4방향에서 쓰레기가 있는 개수를 더해서 더해줬고, 당연하게도 인접한 쓰레기의 개수가 너무 많이 나왔었다.    
우리가 구하는 것은 쓰레기의 개수가 아니고, 인접한 쓰레기를 지나가는 칸의 수이기 때문에 쓰레기가 있다는 여부만 검사하면 된다.    
위에 1,2번만 신경 써서 풀면 다른 bfs 문제와 다를 문제가 없다.