# 문제 풀이
알고리즘 자체는 정말 간단하지만 그 내부 구현이 조금은 복잡했던 문제였다.

N의 크기가 크지 않고, 이동할 수 있는 방향의 개수가 적어서 충분히 완전탐색으로 풀 수 있을 것이라고 판단을 했다.

하지만 고민은 하나의 배열로 풀 수 있을까였다.

퍼즐을 밀고, 해당 탐색을 마친다면 이전의 퍼즐 배열로 돌아와야하는데 하나의 배열을 이용하면 풀 수 없을 것이라고 판단을 했다.

그다음 고민은 재귀를 호출하기 전에 퍼즐을 밀고(배열을 변경하고) 재귀를 호출  ~~ 재귀를 탈출한다면 배열을 다시 원래대로 돌려야 했고, 전역변수로 선언이 아닌 재귀 호출의 파라미터로 넘겨주는 방식을 선택했다.

기존 dfs에서 depth값을 호출 시 depth+1로 호출하는것과 동일한 방법이라고 생각하면 편할 것이다.

즉 나는
```
1. N과 방향이 적기 때문에 완전탐색으로 풀었다.
2. 이전의 퍼즐 배열 상태를 기억해야 하기에, 2개의 배열을 사용했다.
3. 배열을 재귀함수의 파라미터로 넘겨줘서 해당 호출 내에서만 유효하게 사용했다.
```
그다음으로는 위, 아래, 왼쪽, 오른쪽으로 퍼즐을 옮겨주고 합치는 것이다.

기본적인 방법은 3중 포문으로 진행된다.

방향이 위와 아래라면 열을 고정하고 행을 옮겨주면서 퍼즐을 당겨줘야 한다.

방향이 왼쪽과 오른쪽이라면 행을 고정하고 열을 옮겨주면서 퍼즐을 당겨줘야 한다.



퍼즐을 합치는 과정에서 기억해야 할 것이 2가지 있다.
```
1. 합쳐지는 우선순위가 퍼즐을 옮겨주는 방향과 일치하다.
2. 두 블록 사이에 블록이 있으면 합칠 수 없다.
```
위 2가지 사실을 기억하고, 방향에 따라 배열을 당겨주고 비워주면 퍼즐은 쉽게 옮겨줄 수 있다.