# 문제 풀이


**모든 좌표에 대해서 종이를 계속 바꿔가면서 붙이고, 최소한의 종이 개수를 구하면 될 것이라고 판단했다.**

이유는
1. 배열의 크기가 그렇게 크지 않다. 
   - 10*10이므로 n^2이더라도 넉넉하다고 생각했다.
2. 종이의 종류가 많지 않다. 
   - 즉 하나의 좌표에서 종이의 종류대로 붙여가면서 확인을 하더라도 크게 시간이 오래 걸리지 않을 것 같았다.

```text
따라서 나는 종이가 들어갈 수 있는 좌표에 대해서 모든 종이의 경우의 수를 붙여가면서 확인을 했다.
```

보통 이런 방법을 백트래킹이라고 하는데 간단하게 설명하면   
선택지를 통해서 탐색을 하고, 탐색을 마치면 다른 선택지로 탐색을 시작하고, 모든 선택지를 탐색한다.    
우리 문제를 예로 들면

5 x 5 종이를 붙이고, 끝까지 탐색을 하고, 탐색을 마친 뒤 4 x 4 , 3 x 3 .. 이렇게 모든 경우의 수를 탐색하는 것이다.

이런 방법은 `n이 그렇게 크지 않았기에` 가능한 방법이다.    
어떻게 보면 DFS랑 동일하게 보일 수도 있고, 실제로 흐름은 동일하다.    
하지만 백트래킹은 `불필요한 탐색`을 하지 않는다는 것이 차이이다.    

우리는 최소한의 종이의 개수를 구하고 있는데, 탐색을 하는 과정에서 이미 붙인 종이의 개수가 구한 최솟값보다 크거나 같을 경우 굳이 탐색을 할 필요가 있을까?

이런 것을 백트래킹에서 `Promising(유망성 검사)`이라고 하는데 해당 내용까진 자세히 알 필요는 없지만,

간단하게는 탐색할 필요가 없을 경우 탐색을 중지한다고 이해하면 편할 것이다.

이제 해당 문제를 풀때 백트래킹을 선택한 이유에 대해서 설명했고, 코드의 흐름을 간단하게 설명하겠다.

1. 종이를 붙일 수 있는 구역을 ArrayList에 저장
2. count가 answer보다 크거나 같다면 탐색을 중지함. (유망성 검사)
3. DFS의 depth를 통해서 해당 좌표를 검사함.
4. 방문처리가 된 좌표라면 DFS(depth+1,count)를 호출해서 다음 단계를 진행 
5. 종이의 사이즈 별로 해당 좌표에 붙일 수 있는지 없는지 검사함. 
   - 종이가 없거나, 해당 좌표에 종이를 붙일 수 없다면 무시함.
6. 종이를 붙일 수 있다면 종이의 개수를 감소시키고, 방문처리 
7. DFS(depth+1,count+1) 호출 
8. 재귀를 탈출했다면 종이의 개수를 복원시키고, 6번에서 방문처리했던 좌표들을 다시 초기화.
9. [2,3,4,5,6,7,8]을 반복하다가 depth가 끝ㄹ까지 간 경우 결과값을 업데이트 하고 다시 [2,3,4,5,6,7,8]을 진행

