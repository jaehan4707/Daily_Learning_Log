# 문제 풀이

``` text
접근방법에 대해서 많은 고민을 했었다.

시간제한이 1초이고, 이닝의 최대수가 50이며, 순서를 결정해야 하는 타자의 명수는 8명이었다.

그렇다면 시간복잡도는 50 X 8P3 X @인데, 시간복잡도가 1초는 안넘길거 같아서

타자의 대한 모든 경우의 수를 계산해도 문제가 되지 않을것이라고 판단했다.

8P3인 이유는 4번 타자는 첫번째 선수로 결정되었기 때문이다.
```

순열에 대한 코드는 정말 간단하다.

visit 배열을 통해서 포함되었는지, 아닌지를 판단해서 배열에 넣어준다.

기존 player 배열에 4번 인덱스는 1번 타자로 고정시키고, visit [4]도 true이며, 해당 값은 절대 바뀌지 않는다.

이렇게 순열을 통해서 선수에 대한 타순이 결정되었다면 그 다음은 경기 진행방식이다.

경기진행방식은 야구랑 다를게 없다.

아웃카운트가 3개되면 이닝이 종료되고, 종료된 타자에 다음 타자가 이닝을 시작한다.

그러기 위해서 이닝마다 마지막타자를 기억해야 했다.

그리고 9번 타자까지 진행하고, 1번 타자로 돌아가야 하기 때문에

```java
now = (now%9)+1;
```
위 코드를 통해서 1~9번까지의 타순을 강제시켰다.

그다음은 타자가 친 공에 대한 베이스 이동이었다.

타자가 친 공은 0,1,2,3,4에 따라서 베이스 전진이 다르다.

여기서 공통점은

1. 아웃(0)은 모든 주자가 0루를 전진하고, 아웃 카운트가 증가
2. 1루타(1) 모든 주자가 1루를 전진
3. 2루타(2)는 모든 주자가 2루를 전진
4. 3루타(3)는 모든 주자가 3루를 전진
5. 홈런(4)은 모든 주자가 홈으로 돌아온다.

**즉 숫자에 따라서 베이스를 전진한다는 것이다.**

```java
for(int h=0; h<hit; h++){
    mybase.base[4] += mybase.base[3];
    mybase.base[3] = mybase.base[2];
    mybase.base[2] = mybase.base[1];
    mybase.base[1] = 0;
}
```
위 코드를 통해서 베이스에 있는 주자들을 전진했다.

왜 1루는 항상 0인가에 대해서 얘기를 해보면 1루로 전진을 하는 타자는 현재 타자이지, 베이스에 있는 타자들이 아니다.

따라서 항상 1루는 비워준다.

for문을 들어간다는 조건은 hit가 1 이상이기 때문에 치기만 한다면 모든 주자들은 전진을 하기 때문이다.

4번에서 계속 더해주는 이유는 4번에 들어가는 사람의 수가 곧 점수이기 때문이다.

나머지 루는 한 칸씩 당겨주는 역할을 한다.



그렇다면 현재 친 타자는 어떻게 전진시키냐?

```java
mybase.base[hit]++;
```
hit은 타자가 친 루타를 의미한다. 1루타를 쳤으면 1루 베이스로 전진, 2루면 2루로 전진, 홈런이면 그대로 점수로 직행된다.

이렇게 한 이닝이 끝나면 홈에 들어온 주자의 수가 곧 점수로 직결된다.