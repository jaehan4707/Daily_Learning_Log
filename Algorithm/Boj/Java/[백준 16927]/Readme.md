## 문제 풀이

해당 문제의 특이점은 배열 전체를 회전시키는것이회전시키는 것이 아닌 각 인덱스의 원소들을 회전시키는 것이다.

통째로 회전하는 것과 소용돌이처럼 회전시키는 것은 아예 다른 문제이다.

소용돌이식 회전을 위해서 어떻게 해야 할지 고민을 해봤다

#### n*n 반복문을 돌리면서 각 위치에 맞게 돌리기

> 사실상 불가능한 영역이라고 판단했다.  
> 해줘야 할 연산도 굉장히 많고, 최대 300 크기의 배열을 식을 세워서 회전하는 것은 쉽지 않을 것이라고 생각했다.

규칙을 찾기 위해서 무작정 손으로 그려봤다.

![](https://blog.kakaocdn.net/dn/c2Ujsx/btsDxiPdzWR/bcT2TLKN0qs9FggBYKgMQ1/img.png)

그림을 그리다 보니 규칙이 보였다.

규칙은 바로 사각형의 층마다 껍데기가 존재하고 같은 껍데기에 포함되어 있는 숫자들만 회전을 하는 것이었다.

#### depth에 맞는 껍데기에 원소들만 회전시키기

행렬과 회전의 특성만 기억한다면 , 껍데기의 개수는 간단하게 구할 수 있었다.

![](https://blog.kakaocdn.net/dn/bIfSew/btsDuSJ1YHB/4LXzjwCKTr39HxQekk5aKk/img.png)

위 행렬은 행의 개수가 3, 열의 개수가 4인 행렬이다.

위 행렬의 껍데기 수는 1개이다. 

즉 색깔로 칠해진 영역만 회전하는 것이다.

하나의 예를 더 들자면

![](https://blog.kakaocdn.net/dn/AJ6Si/btsDxKq01OF/MC6ppKZ9o06KqgwGnrhfuk/img.png)

위 행렬은 행의 개수가 6 열의 개수가 5인 행렬이다.

행렬의 껍데기 수는 2개이다.

즉 껍데기의 수는 행의 개수와 열의 개수 중 작은 것의 절반값이다.

이렇게 회전을 1번 할 때마다 껍데기들을 회전시켜 줬다.

회전 알고리즘은 구현하기 나름이므로 설명은 생략하겠다.

그 후 회전알고리즘을 적용해서 제출했더니 시간초과가 발생했다.

![](https://blog.kakaocdn.net/dn/cgpGJw/btsDuUOBF72/bEa0apJU8Ze51JEjwfUD3K/img.png)

간과한 것이 있다면 회전의 수에도 규칙이 있고, 일정한 수의 회전을 진행하면 제자리로 돌아오는 규칙이 있다.

즉 회전의 수를 전부 다 할 필요가 없이, 규칙을 찾아야 한다는 것이다.

그러기 위해서 하나의 지점에서 얼마나 이동해야 제자리로 돌아오는지 계산했고, 규칙을 찾았다.

사각형의 전체 변의 길이에서 꼭짓점을 뺀 횟수만큼 회전을 할 경우 제자리로 돌아왔다.

이건 직접 해보면 알 수 있을 것이다. 꼭짓점을 뺀 이유는 꼭짓점에서 방향전환이 일어나기 때문에 횟수에서 빼주는 것이다.

이런 돌아오는 길이를 안다면 회전을 전부 다 할 필요 없이 회전% 길이의 값으로만 회전을 하면 똑같은 결과를 얻을 수 있다.

항상 문제를 잘 읽고.. 최악의 경우의 수까지 생각을 해야 하는데 쉽지가 않은 것 같다.ㅠ