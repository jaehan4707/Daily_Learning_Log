
| 문제                                         | 분류 | 티어  |
|--------------------------------------------|----|-----|
| [로또](https://www.acmicpc.net/problem/2758) | DP | 골드4 |

### 문제 풀이

DP 배열은 다음과 같이 생각했다.

dp[i][j] = i개의 숫자를 골라서 j가 마지막인 수열의 개수

즉 만약 dp[2][2]라면 2개의 숫자를 골라서 2가 마지막인 수열의 개수이다.

해당 값은 1 2로 값은 1이다.

그렇다면 dp[1][n]의 값은 무조건 1이 될것이다.  
첫 시작은 가능하기 때문이다.

그 이후부터는 숫자의 절반을 만드는 경우의 수가 존재하는지 검사해야 한다.   
예를 들어 dp[3][4]를 검사하려면 2개의 숫자를 조합해서 4/2 값 이하인 숫자들을 만들 수 있는지 확인해야 한다.   

즉 나는 점화식을 이렇게 세웠다.  
j를 만들기 위해서 검사할 때
```java
for(int i=2; i<=n; i++){
    for(int j=1; j<=2000; j++){
        for(int k=0; k<=j/2; k++){
            do[i][j] +=dp[i-1][k];
        }    
    }
}
```

수의 최대 범위가 명확히 지정되어 있고, 한번 계산하면 그 값을 이용하면 되기 때문에 초기의 최대 범위로 계산을 돌리고 입력된 n,m 값에 맞는 dp 값을 출력하면 끝이다.