# Cookie

---

> 쿠키는 문자와 숫자의 조합으로 된 작은 파일이다.
>

서버는 쿠키를 통해서 클라이언트를 식별하고 이에 맞춰서 다양한 서비스를 제공한다.

사용자가  특성 사이트에 처음 접속하면 그 사이트 서버는 사용자에게 Cookie header라는 숫자를 부여해준다. 브라우저는 부여받은 Cookie header와 사이트 이름을 조합하여 만들어진 쿠키 파일을 사용자의 컴퓨터에 저장한다.

과정

![Untitled](https://file.notion.so/f/f/bea1f681-e907-4ad0-8d9e-c46aa582a35d/86acc03c-976f-46d9-b556-613102d96874/Untitled.png?id=82c8ed2b-acdc-4de8-8254-ad2738dae529&table=block&spaceId=bea1f681-e907-4ad0-8d9e-c46aa582a35d&expirationTimestamp=1709467200000&signature=GVW6tgNxQz4CeAidOfj9wcxx15H9cfF7F9vQHq7iIi8&downloadName=Untitled.png)

- 사용자 사이트 접속
- 사용자의 쿠키 파일 전송
- 서버는 쿠키 파일을 통해 사용자를 식별

즉 쿠키는 해당 웹 사이트를 방문한 사용자의 습관을 기록하는것이다.

### 쿠키의 목적

- 세션 관리
    - 쿠키를 사용하면 서버에 저장해야 할 로그인, 장바구니 등의 정보를 관리할 수 있다.
- 서비스 개인화
    - 서비스에서 사용자가 커스터마이징 할 수 있는 정보나  테마 등의 세팅 값을 쿠키에 저장할 수 있다.
- 트래킹
    - 서비스에서의 사용자의 행동 정보를 기록할 수 있다.

### 단점

- 쿠키는 사이트가 사이트에서 사용자에 대해 더 많은 것을 알 수 있게 해준다.
    - 사용자의 정보 노출 우려
- 사용자의 서비스 상의 행동이 쿠키에 기록되어 저장장치에 남아서 나중에 타인에 의해 조회될 수 있으므로 이는 프라이버시 문제를 야기할 수 있다.

따라서 쿠키는 언제든지 변조 될 수 있고, 다른이에게 노출될 가능성이 높은 저장방식이기 때문에 절대로 쿠키에 기밀 또는 민감한 정보를 담으면 안된다.

# Web caches(proxy servers)

---

### Web caches의 목표

클라이언트가 요청을 할 때마다 orgin server에서 받아오는것은 비효율적이다.

왜냐하면 origin server에 요청을 하고 해당 요청을 받아서 클라이언트에게 다시 내려주기 때문

자주 사용하는것은 미리 빼두면 되지 않을까? 혹은 미리 준비해주면 되지 않을까?라는 생각에서 출발한 개념이 Web caches이다.

![Untitled](https://file.notion.so/f/f/bea1f681-e907-4ad0-8d9e-c46aa582a35d/aaffeb9c-bc30-46d4-a17a-e4d6945566de/Untitled.png?id=abc8320a-a71f-45ca-a987-30aa15f2e2fc&table=block&spaceId=bea1f681-e907-4ad0-8d9e-c46aa582a35d&expirationTimestamp=1709467200000&signature=JD3rNZdypvVYsiOzMBR56vvrBQpGxubgXU4q9U1zZdE&downloadName=Untitled.png)

1. 클라이언트는 origin server가 아닌 Web caches에 요청을 합니다.
2. Web caches에 있다면 클라이언트에게 요청한것에 대해 반환해줍니다.
3. Web caches에 없다면 origin server에 요청을 하고 그 요청을 캐쉬가 받아서 반환한다.

- 클라이언트가 요청을 하면 origin serer에서 콘텐츠를 받아오는것이 아닌 caches를 통해서 받아오는것

# Session

---

```java
클라이언트가 브라우저에 접속하여 서버와 접속이 종료하기 전의 상태
```

쉽게 설명하면 사용자가 웹 사이트에 접속해 해당 창을 닫기 전까지의 상태

예를 들면 로그인을 한 사이트의 로그인 상태가 유지되는것.

특징

- 쿠키를 기반으로 함
- 사용자 정보 파일을 서버 측에서 관리한다.
- 브라우저가 종료할때까지 상태가 유지된다.

# Vs 쿠키

---

|  | 쿠키                                                      | 세션                     |
| --- |---------------------------------------------------------|------------------------|
| 저장 위치 | 클라이언트                                                   | 서버                     |
| 보안 | 변질, request중 sniffing 위험이 있어 취약                         | 서버 내에서 처리하기때문에 보안성이 좋다 |
| 생명주기 | 만료 기간을 설정할 수 있으며,파일 형태로 저장되기 때문에 브라우저 종료 후에도 남아있을 수 있다. | 브라우저 종료 시 삭제 |
| 속도 | 빠름                                                      | 느림 |

# 예상 질문

---

### Q1) 세션 방식의 로그인 과정에 대해 설명해주세요

```java
1. 클라이언트가 웹 사이트에 접속해 서버에 요청한다.
2. 서버는 접속한 클라이언트에게 SessionID를 부여해서 응답한다.
3. 클라이언트는 해당 SessionID를 헤더 쿠키에 넣어 데이터를 요청한다.
4. 서버는 SessionId를 통해 클라이언트를 구별하여 데이터를 알맞게 응답한다.
5. 클라이언트가 접속을 종료하면 서버는 세션 ID를 제거한다.
```

### Q2) HTTP의 특성인 Stateless에 대해 설명해주세요

```java
HTTP는 연결을 끊는 순간 통신이 끝나며 상태 정보를 유지하지 않는 특성때문에 
HTTP를 Stateless하다고 한다.
이러한 특성때문에 계속해서 통신할때마다 새로 커넥션을 열기 때문에 
클라이언트는 인증을 계속해야하는 단점이 있었고, 클라이언트의
상태정보를 저장하는 쿠키와 세션이 등장했다.
```

### Q3) Stateless의 의미를 살펴보면 세션은 적절하지 않은 인증방법이 아닌가?

```java
어떻게 보면 세션이란 방식을 통해서 클라이언트의 상태를 저장하고 있기 때문에
이는 Stateless와는 상반된 방식이다.
하지만 Stateless를 유지하기 위해 드는 비용(매 요청마다 필요한 정보를 담는)이
너무 부담이고, 웹 서비스가 발전함에 따라 클라이언트의 상태를 유지하는 경우가 많아졌기 때문에
적절하지 않지만 기술 발전에 따라 어쩔수 없다고 느낀다.
```

### Q4)규모가 커져 서버라 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까?

```java
여러 서버가 공유하는 캐시를 사용하여 세션을 관리할 수 있을것 같다.
하지만 여러 서버가 동일한 캐시를 공유하기 때문에 캐시에 문제가 생기면 여러 문제를 야기될
수 있을것 같다.
```

# 참고
https://velog.io/@98soonrok/CS%EA%B3%B5%EB%B6%80-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-2