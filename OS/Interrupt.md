# Interrupt

```jsx
CPU가 프로그램을 실행하고 있을 때 하드웨어 등의 장치 사용이나 프로그램
내 예외상황등이 발생하여 처리가 필요할 때 프로세서에게 이를 알려주는 것
```

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbWgRCr%2Fbtrfw50VcNF%2FbK2gyyOyshYKr0t4X4Dkn1%2Fimg.png)

## Polling(폴링)

```
운영체제가 장치 사용을 감시하기 위해 장치의 동작 여부를 수시로 체크하는 것
장치 사용을 매번 검사하는것은 비효율적이기 때문에 이벤트 발생 시 알려주는 인터럽트가 등장
```

인터럽트에는 크게 하드웨어와 소프트웨어로 나뉘고, 시스템 콜 역시 이와 비슷한 역할을 수행하여 프로세스에게 유저 모드에서 커널 모드로 가서 특정 작업을 수행할 것을 요구하게 됩니다.

## HW Interrupt

![](https://github.com/devSquad-study/2023-CS-Study/raw/main/OS/img/os_i_hardware_Interrupt_Process_1.png)

```
하드웨어가 발생시키는 인터럽트로, CPU가 아닌 다른 하드웨어 장치가 CPU에 어떤 사실을 알려주거나,
CPU 서비스를 요청해야 할 경우 발생시킨다. 정전 또는 전원 공급의 이상, CPU 또는 기타 하드웨어의
오류 등도 하드웨어 인터럽트에 포함된다.
```

## SW Interrupt(Exception)

![](https://camo.githubusercontent.com/fcab8b0a27f1e44b67d62a8bce904320ec9a63f450943e5da9a3a7473102238d/68747470733a2f2f6b2e6b616b616f63646e2e6e65742f646e2f516e714c682f62747176414243374561322f73666c50566972784e6457584f69516b633843517a312f696d672e706e67)

```jsx
CPU 내부에서 실행되면서 인터럽트를 발생시키는 경우로써 프로그램 코드를 돌리는 과정에서 
Exception이 발생할 때 Kernel Mode로 전환하여 에러를 핸들링하는 경우를 말한다.
예시로는 Divide by Zero, Overflow, Underflow등이 있다.
```

## System Call

```
사용자가 프로그램을 실행시키거나 OS를 호출하는 동작을 수행하는 경우에 일어난다.
모든 프로그램은 자신의 독자적인 주소 공간을 가지고 있으며 프로그램이 함수를 호출하는 경우
자신의 주소 공간 내에서 호출이 이루어지게 된다.
그러나 System call은 함수임에도 불구하고 자신의 주소 공간이 아닌 Kernel 영역의 함수를 호출한다.
```

구체적인 시스템 콜의 예시로는 파일 생성,삭제,열기,닫기,읽기,쓰기부터 장치 관리, 정보 유지와 통신을 하는 것 등이 있으며, 특정 프로그램이 CPU를 독점하는 것을 방지하기 위해 CPU 할당 시간이 만료되면 인터럽트를 발생시켜 프로세스 처리를 분할하는것 역시 시스템 콜의 역할이다.

## 인터럽트 처리 +과정

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbYX0X1%2Fbtq7jDkswSK%2FAtzvA6qQOa2TZLQOAE8T9K%2Fimg.png)

인터럽트가 발생하면 크게 아래 여섯 단계를 거치게 된다.

1. 프로그램 실행을 중단
2. 현재의 프로그램 상태를 보존(Context Switching)
3. 인터럽트 처리 루틴을 실행
4. 인터럽트 서비스 루틴을 실행
5. 인터럽트 요청 신호가 발생했을 때 보관한 PC의 값을 복원한다.
6. PC의 값을 이용해 인터럽트 발생 이전에 수행중이던 프로그램을 계속 실행한다.

인터럽트 처리 루틴

- 인터럽트의 원일을 파악하는 일련의 과정을 의미한다.

인터럽트 서비스 루틴

- 인터럽트 핸들러라고도 하며 실제 인터럽트를 처리하는 루틴으로 실행중이던 레지스터와 PC를 저장하여 실행중이던 CPU의 상태를 보존하고 인터럽트 처리가 끝나면 원래 상태로 복귀하는 일련의 과정

### 인터럽트 발생 처리 예시 시나리오

```
A 프로그램이 CPu를 할당받고 명령을 수행하고 있는데 인터럽트가 발생하면 A는 현재 수행중인 
명령의 위치를 저장해 놓는다. 그 후, 운영 체제 내부 코드인 인터럽트 처리 루틴으로 넘어가서
인터럽트 처리를 하고 다시 돌아와 A의 이전 작업 지점부터 수행을 계속 이어나간다.
```

진행중이던 A 프로세스의 정보는 PCB(Process Control Block)에 저장한다. 그리고 인터럽트 처리를 모두 마치면 프로그램 A의 PCB에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다.

### 인터럽트 벡터

- 여러가지 인터럽트에 대해 인터럽트 발생 시 처리해야할 루틴의 주소를 보관하고 있는 테이블
- 일종의 함수를 가리키는 포인터

### 인터럽트 핸들러

- 실제 인터럽트를 처리하기 위한 루틴으로 `인터럽트 서비스 루틴`이라고 한다.
- 운영체제 코드 부분에는 각종 인터럽트 별로 처리해야 할 내용이 이미 프로그램 되어 있으며, 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 한다.

```
예를 들어 입출력 관련 인터럽트가 발생한 경우, CPU는 인터럽트 라인을 통해 발생한 인터럽트를 
확인한다. 인터럽트 벡터를 통해 해당 인터럽트 발생 시 처리해야 할 루틴의 메모리 주소를 알아낸다.
주소를 통해 실제 수행되어야 할 코드가 담겨 있는 루틴을 찾아가 상황에 맞는 
처리를 진행한다.
```

## 여러 개의 인터럽트가 발생할 경우

> 네트워크를 통해 데이터를 받아서 결과를 프린터에 출력하는 프로그램
>

프린터는 결과를 출력할 때마다 인터럽트를 발생시킬것이고, 네트워크 컨트롤러는 데이터가 도착할 때 까지 인터럽트를 발생시킨다.

만약 프린터 인터럽트가 처리되는 도중에 네트워크 인터럽트가 발생한다면 어떻게 될까?

처리방법

1. **하나의 인터럽트가 처리되는 동안 다른 인터럽트의 발생을 중지시킨다.**

프로세서가 인터럽트 신호를 무시하는데, 한 인터럽트가 처리 될 동안 다른 인터럽트는 대기 상태(pending) 상태가 되어 이후에 프로세서가 인터럽트 발생을 다시 허용했을때 처리된다.

- 인터럽트가 발생한 순서대로 처리된다는 장점이 있지만 빨리 처리되어야 하는 인터럽트를 고려하지 못한다는 단점이 있다.

1. 인터럽트 간에 우선순위를 매겨 처리한다.

![Untitled](https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/os/what-is-interrupt/fig8.png)

> t=0
>
- 유저 프로그램이 시작된다.

> t=10
>
- 프린터 인터럽트가 발생하여 유저 프로그램의 시스템 스택에 저장되고, 프로그램의 흐름이 프린터의 ISR로 넘어간다.

> t=15
>
- 커뮤니케이션 인터럽트가 발생한다.
- 커뮤니케이션의 우선순위는 프린터보다 높기 때문에 인터럽트가 수락되어 처리된다.
- 이 때 프린터의 상태가 스태겡 저장되고, 프로그램의 흐름이 커뮤니케이션 ISR로 넘어가게 된다.

> t=20
>
- 디스크 인터럽트가 발생하지만, 우선순위가 커뮤니케이션보다 낮기 때문에 대기 상태가 되고,
  여전히 커뮤니케이션 ISR이 실행된다.

> t=25
>
- 커뮤니케이션 ISR이 종료되면 프로그램의 흐름이 프로세서의 이전 상태인 프린터 ISR로 다시 넘어간다.
- 프린터 ISR이 실행되기 전에 대기하고 있던 디스크 인터럽트(우선순위가 더 높음)가 수락되어
  프로그램의 흐름이 디스크 ISR로 넘어간다.

> t=35
>
- 디스크 ISR이 끝나고 프린터 ISR의 실행이 재개된다.

> t=40
>
- 프린터 ISR이 종료되고, 프로그램의 흐름이 최종적으로 다시 유저 프로그램으로 넘어가서 모든 인터럽트가 처리된다.

---

# 예상 질문

> Q1 : 인터럽트는 무엇인가?
>

```
CPU가 다른 프로그램을 실행하고 있을때, 하드웨어의 오류나 소프트웨어적인 오류가 발생해서 
CPU에게 오류가 발생했다고 알리는 것.
```

> Q2 : 인터럽트는 어떻게 처리하는가? 처리 과정에 대해서 설명해라
>

```
1. 프로그램 실행을 중단한다.
2. 프로그램의 정보를 PCB에 저장한다.
3. 인터럽트 처리 루틴을 실행한다. 해당 과정에서 인터럽트 벡터를 통해서 인터럽트 서비스를 요청
4. 인터럽트 서비스 루틴을 실행한다.
5. 인러텁트가 처리된다면 이전에 저장한 PCB에 있는 PC값을 복원해서 이전 실행 위치로 돌아간다.
6. 이어서 프로그램을 실행한다.
```

> Q3: Polling 방식에 대해 설명해주세요
>

```
CPU에 문제가 발생했는지, 장치에 오류가 없는지 지속적으로 관찰하는 방법으로,
문제가 생길때마다 CPU에 알리는 인터럽트보다 비효율적인 방식이다.
이유는 지속적으로 관찰하는 상황에서 CPU 자원을 낭비하기 때문.
```

> Q4: HW/SW 인터럽트에 대해 설명해주세요
>

```
하드웨어 인터럽트는 하드웨어가 발생시키는 인터럽트로, 
하드웨어 장치에서 오류가 생기거나, 하드웨어 장치가 CPU에게 어떤 사실을 알려주거나,
하드웨어 장치에서 CPU에게 요청을 할 때 발생하는 인터럽트이다.

소프트웨어 인터럽트는 CPU 내부에서 코드가 실행되면서 발생한 인터럽트로, 
대표적인 예로 Overflow, Underflow, Divide by zero 같은 Exception과 System call이 있다.
```

> Q5: 동시에 두 개 이상의 인터럽트가 발생하면 어떻게 처리해야 하나

```
1.인터럽트를 처리하는 동안 다른 인터럽트의 발생을 막아준다.
이렇게 하면 여러 개의 인터럽트에 대해서 처리할 수 있다.
하지만 이 방법의 단점은 인터럽트의 우선순위가 역전되는 상황이 발생할 수 있다.
발생한 순서대로 처리하기 때문이다.

2.인터럽트마다 우선순위를 부여해서, 인터럽트를 처리하는 동안 다른 인터럽트가
발생했다면 그들의 우선순위를 비교해서 인터럽트를 처리한다.
```