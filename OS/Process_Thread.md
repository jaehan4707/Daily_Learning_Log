# Process vs Thread

# Process

<aside>
💡 컴퓨터 분야에서 프로세스는 컴퓨터 프로그램의 인스턴스로, 하나 이상의 스레드를 통해 실행된다.

</aside>

프로그램이 실행되면 → 프로세스 인스턴스가 생성된다. → 프로그램 실행에 필요한 내용이 컴퓨터 메모리에 적재된다는 뜻.

프로세스와 프로그램은 다른 개념이다.

- 프로그램
    - 어떤 작업을 하기 위해 실행할 수 있는 파일 또는 프로그램
- 프로세스
    - 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태

# 멀티 태스킹

멀티태스킹이란 OS를 통해 CPU가 작업하는데 필요한 자원을  프로세스 또는 스레드간에 나누는 행위를 말한다. 이를 통해 여러 응용 프로그램을 동시에 열고 작업 할 수 있다는 장점이 있다.

ex 음악을 들으면서 , 웹 서핑을 하고, 메신저의 메시지를 확인하는 행위

![](https://blog.kakaocdn.net/dn/cjMhI9/btsDzxNxpg9/EJWqi3rCqQTX6fQDdTCA5K/img.png)


그림에서는 여러 프로세스가 동시에 실행되고 관리 되는것처럼 보이지만, 사실 CPU는 한번에 한가지 명령어 밖에 처리하지 못한다.

## 동시성(Concurrency)

둘 이상의 작업이 동시에 실행되는 것을 의미한다.

여기서 말하는 동시는 같은 시간에 실행되는 동시성이 아닌 동시에 실행하는것처럼 보인다는 의미이다.

예를 들어서 N개의 사람이 동시에 작업을 하는것이 아닌 1명씩 돌아가면서 작업을 하는데,

교대하는 시간이 엄청나게 빨라서 동시에 작업하는것처럼 느껴지고, 이것이 프로그램에서 말하는 동시성이다.

이렇게 재빠르게 프로세스들을 번갈아가면서 실행하고 관리하는것이 Context Switching이다.

# Context Switching

하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업.

OS의 스케쥴러에 의해 발생하고, CPU를 적절하고 효율적으로 사용할 수 있도록 하는것이 스케줄링이다.

# CPU Scheduler

- 레디 큐에 존재하는 프로세스들을 우선순위 기반으로 CPU를 할당받게 해줌.
    - CPU 최대한 활용
    - 대기 시간 최소화
    - 처리량 극대화

# Scheduling Algorithm

- FCFS : 선착순  (queue)
- SFJ : 최단 작업을 우선시 하는 스케쥴링
- Priority Scheduing : 우선순위에 따라서 스케쥴링 하는 방식
- RR : 정해진 시간만큼 프로세스할당하고, 차례를 넘기는 방식
- Multilevel -Queue : 레디큐를 여러 개의 큐로 분류하여 각 큐가 다른 스케쥴링 알고리즘을 갖ㅁ.

# PCB 와 프로세스의 상태

프로세스 제어 블록(Process Control Block)를 줄여서 PCB라고 한다.

특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조이다.

PCB가 필요한 이유는 Context Switching 때문.

여러 프로세스를 빠르게 번갈아가면서 작업을 하기 때문에

프로세스의 정보와 상태를 저장/복원 할 필요가 있다.

포함되는 정보

- 프로세스 식별자 (PID)
- 프로세스 상태
- 프로그램 계수기
- CPU 레지스터 및 일반 레지스터
- CPU 스케줄링 정보
- 메모리 관리 정보
- 프로세스 계정 정보
- 입출력 상태 정보

# 프로세스 상태


![](https://blog.kakaocdn.net/dn/cwmpDF/btsDBzQ44Kb/K6MJEzZkwp1fkGz0OiPjp1/img.png))

- new : 프로세스가 생성되는 상태
- ready : 프로세스가 CPU에 할당되어, 처리되기를 기다리는 상태
- running: 프로세스가 CPU에 할당되어, 명령어들이 실행 되는 상태
- waiting: 어떤 이벤트의 발생으로 인해 프로세스가 기다리는 상태
- terminated: 프로세스가 종료도는 상태

# Context switching 과정

![](https://blog.kakaocdn.net/dn/bKuzPl/btsDCWrK9Wv/iZ82WRKgjiXZo7A5Skiz40/img.png)

프로세스 A가 실행중(running)이고 프로세스 B는 대기상태(Reday)이다.

이 상태에서 interrupt나 시스템 콜이 발생하면 P0은 Running → Ready로 전환한다.

추후 복원될 A를 위해 해당 프로세스 정보를 PCB에 담아 저장.

B는 이전에 저장한 PCB로부터 상태를 복원해서 작업을 수행

즉 PCB를 통해서 프로세스는 이전의 상태를 복원해서 작업을 진행함.

하지만 Context Switching은 메모리에 I/O를 하는 작업이기때문에 실행되는 프로세스의 수가 많거나, Context Switcing의 빈번한 발생은 Overhead를 발생시켜 성능 저하라는 결과를 가져온다.

# 메모리 영역

<aside>
💡 프로세스는 독립된 메모리 영역(Code,Data,Stack,Heap)을 할당받는다.

</aside>


![](https://blog.kakaocdn.net/dn/xAAGg/btsDArMIs9Z/vIifYQxh4FeKIxSFncxuJ0/img.png)



## Code

- 실행할 프로그램의 코드 및 매크로 상수가 기계어 형태로 저장되는 영역이다.

## Data

- 코드에서 선언한 전역 변수와 정적(static) 변수가 저장되는 영역
- 데이터 영역은 프로그램의 시작과 함께 할당되어 종료될 때 소멸된다.

## Stack

- 스택 영역은 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장되고 함수 호출 시 기록하고 종료되면 제거한다. [후위선출]
- 재귀 함수의 깊이가 깊어질 경우 Stack OVerFlow가 발생이 예

## Heap

- 관리가 가능한 데이터 이외의 다른 형태의 데이터를 관리하기 위한 공간이다.
- 이 공간은 동적 메모리 할당 곤간이므로 사용이 끝나면 운영체제가 쓸 수 있도록 반납해야한다.
- 프로그램이 실행하는 순간 프로그램이 사용할 때 메모리 크기를 고려하여 메모리으 할당이이루어지는 데이터 또는 스택과 같은 정적 메모리 할당과는 대조적이다.
- 동적 메모리 할당은 어느 시점에 어느 정도의 공간을 할당할 수 있을지 예측 불가능하기 때문에 → 런타임에서 확인가능

<aside>
💡 Stack과 Heap 영역은 실행되는 동안 크기가 변화하는 동적영역이다.
반대로 code와 data 영역은 선언할 때 크기가 결정되는 정적영역ㅇ다.

</aside>

# 프로세스의 자원 공유

프로세스는 메모리에 별도의 주소 공간에서 실행되기 때문에, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.

- IPC(Inter-Process Communication)
- LPC(Local inter-Process Communication)
- 별도로 공유 메몰를 만들어서 정보를 주고받도록 설정

# 프로세스의 한계

과거에는 프로세스 하나만을 사용하기에 충분했지만, 기술이 발전됨에 따라 프로그램이 복잡해지고 다채워로짐으로써 하나의 프로세스는 한계가 있었음.

프로세스가 하나인 경우는 파일 다운에서 실행 시작부터 실행 끝까지 하루종일 기다려야 하지만,

동일한 프로그램을 여러 프로세스로 만들게 되면 메모리를 차지하고, CPU에서 할당받는 자원이 중복되게 될 것이다.

스레드는 이러한 프로세스의 특성의 한계를 해결하기 위해 탄생했다.

# Thread

<aside>
💡 컴퓨터 분야에서 실행되는 스레드는 일반적으로 운영체제의 일부인 스케줄러에 의해 독립적으로 관리 될 수 있는 프로그래밍 된 명령어의 가장 작은 시퀀스다.

</aside>

![](https://blog.kakaocdn.net/dn/MmNhq/btsDCWecKJf/JSk18ij4cWBtoxviE4Igik/img.png)


간단하게 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.

일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 갖는다.

즉 프로세스를 생성하면 기본적으로 하나의 스레드가 생성된다.

![](https://blog.kakaocdn.net/dn/dbyRZ4/btsDBQrNFIY/ecVKUmCYuow2rEVWJJrc6k/img.png)


프로세스는 실행될때 독립된 메모리 영역을 할당받음(code,data,stack,heap)

스레드는 한 프로세스 내에서 동작되는 흐름으로 프로세스 내에서 Stack 영역만 별도로 할당 받고, 부모 프로세스의 Code,Data,Heap 영역은 공유한다.

즉 프로세스 내에서 자식 스레드들은 서로 주소 공간이나 자원들을 공유하면서 실행될 수 있다.

이러한 점 덕분에 스레드는 프로세스 내의 자식들과 자언을 공유하고, 자원의 생성과 중복성을 최소화할 수 있고, 수행능력이 증가한다.

<aside>
💡 Stack은 함수 호출, 리턴 주소값, 선언하는 변수 등을 저장하는 메모리 공간익 때문에,
독립적인 스택을 가졌다는 것은 독립적인 함수 호출이 가능하다는 의미이다.
그 의미는 곧 독립적인 실행 흐름이 추가 된다는 말이다.
즉 Stack을 가짐으로써, 스레드는 독립적인 실행 흐름을 가질 수 있게 되는것.

</aside>

# 멀티 프로세스


![](https://blog.kakaocdn.net/dn/DE8Sg/btsDD1zf0Xe/rbzwhaDfUZ8y630qrYt840/img.png)



하나의 프로그램을 여러개의 프로세스로 구성해서 각 프로세스가 하나의 작업을 처리하도록 하는 것.

특징

- 안정성이 좋다.
    - 다수의 자식 프로세스가 있기 때문에, 하나가 잘못되더라도, 다른 자식 프로세스에 영향이 확산되지 않는다.
- 구현이 비교적 간단하다.
- 각 프로세스들이 독립적으로 동작하며 자원이 서로 다르게 할당 된다
- 프로세스 간 통신을 위해 IPC를 통해야 한다.
- 메모리 사용량이 많다.
- 스케쥴링에 따라 Context Switching이 많아지고. 성능 저하의 우려가 있다.

# 멀티 쓰레드

하나의 어플리케이션을 여러 개의 스레드로 구성하여 하나의 스레드가 하나의 작업을 처리하도록 하는것.


![](https://blog.kakaocdn.net/dn/cm9OUG/btsDxUvog2y/Jy1jRcxJXnkZjuOKjT5Nt1/img.png)


사용 이유는 사용자와 상호작용하는 어플리케이션에서 단일 스레드로 Network 또는 DB와 같은 긴 작업을 수행하는 경우 해당 작업을 처리하는 동안 사용자와 상호작용이 불능인 상태가 될 수 있기 때문에 여러개의 스레드를 두어 서로에게 방해주지 않고 각자 할일을 하는 모습

- 응답성이 좋다. 프로그램의 일부분이 중단되어도 프로그램이 계속적으로 수행된다.
- 자원 공유가 쉽다. 스레드들은 부모 프로세스의 자원과 메모리를 공유할 수 있다.
- 프로세스를 할당하는것보다 스레드를 할당하는것이 비용이 적다.
- 멀티 프로세서 구조에서 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다.
- 구현 및 테스트 디버깅이 어렵다.
- 너무 많은 스레드 사용은 오버헤드를 발생시킨다.
- 동기화 그리고 교착상태가 발생하지 않도록 주의해야 한다.
- 자식 스레드 중 하나에 문제가 생긴 경우 전체에 영향을 준다.


# 예상 질문

> Process와 Thread의 차이점
>
- Process는 운영체제에서  자원을 할당 받은 작업의 단위이고, Thread는 프로세스가 할당 받은 자원을 이용하는 실행 흐름의 단위이다.
- Process는 하나 이상의 Thread를 가진다.

> Multi Process & Multi Thread에 대해서 설명해보라(장점,단점)
>

Multi Process와 Multi Thread 모두 프로그램의 병렬성을 보장하기 위한 방법이다. 하지만 이러한 두가지 방법도 Thread와 Process를 이용하는 다른 방법이기에 장점과 단점이 존재한다.

**안정성 측면**

멀티 프로세스는 각 프로세스가 독립적인 메모리 공간을 차지하기 때문에 한 프로세스가 비정상적으로 종료되어도 다른 프로세스에 영향을 주지 않는다.

멀티 쓰레드는 하나의 프로세스 내에서 여러개의 스레드가 작업을 진행한다.
하나의 스레드에서 문제가 발생하면 다른 스레드들도 영향을 받아 전체 프로그램이 종료될 수 있다. 하지만 예외처리나 스레드 풀의 개념을 이용해서 에러 발생시 새로운 스레드를 쓰레드 풀에서 가져와서 종료를 방지할 수 있지만 이러한 예외처리 모두 개발적인 비용이 발생한다.

**Context Switching Overhead**

Context Switching은 멀티 태스킹을 구성하는데 핵심 기술이다.

간단하게 설명하면 CPU에 자원을 할당받아서 프로세스와 쓰레드가 작업을 진행하는데, CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 CPU 활용률을 높이기 위해 여러개의 CPU에 작업시간과 우선순위를 부여하고, 프로세스에게 자원을 할당하는 기술이다.

멀티 프로세서에서 Context Switching은 다음 프로세스의 정보를 불러오기 위해메모리를 검색하고, CPU 캐시 메모리를 초기화, 프로세스 상태를 저장하고, 불러올 데이터를 준비해야 하기 때문에 오버헤드가 발생한다.

하지만 멀티 쓰레드에서의 Context Switching은 멀티 프로세스보다 가볍고 빠르다. 이유는 하나의 프로세스 내에서 스레드를 교환하고, 캐시 메모리를 초기화하지 않기 때문이다.

**자원 공유의 효율성**

Process는 다른 프로세스에 접근이 불가능하다.

독립적인 프로세스이기 때문에 자원을 공유하기 위해서 특별한 방법인 IPC를 사용하는데, 이러한 기법은 성능 저하 발생의 우려가 있고, 코드또한 매우 복잡하다.

하지만 Thread는 하나의 프로세스 내에서 여러 개의 스레드가 생성되고, Stack 영역을 제외한 다른 영역은 공유해서 사용하기 때문에 스레드 간에 자원 공유가 가능하다.

하지만 여러 스레드가 공유 자원에 동시에 접근하는 문제를 해결하기 위해 동기화라는 기술이 필요하다. 하지만 이러한 동기화작업은 병목 현상이 일어날 가능성이 높다. 이에 대한 해결 방법으로는 임계영역, 뮤텍스, 세마포어 방식이 활용된다.

> Thread Safe는 어떤 의미인가, 보장하기 위해서 어떤 방법을 사용할 수 있는가?
>

멀티 스레드 환경에서 여러 스레드가 동시에 공유자원에 접근할 때 의도한 대로 동작하는 것을 의미한다. (즉 오류가 없는 상황)

Multi Thread를 보장하기 위해선 공유 자원에 여러개의 스레드가 임계영역에 접근할때 동기화 기법을 통해서 제어해야한다.

대표적인 기법은 임계 영역에 진입하기 전에 락을 획득하고, 임계 영역을 빠져 나올때 락을 해제하여 하나의 스레드가 공유 자원에 접근할 수 있도록 제어하는 기법인 Mutex와 동시에 접근 가능한 스레드의 개수를 지정하는 세마포어 기법이 있다.

> Context Switching이란?, 언제 일어나냐
>

CPU는 한번에 하나의 프로세스만 처리할 수 있다.

CPU의 효율을 높이기 위해 여러 프로세스를 처리해야하는 상황에서 생겨난 기술이 Context Switching이고, 다른 프로세스에게 CPU를 할당하고, 작업을 수행하는 과정을 의미하는데,

진행중인 Process의 정보를 PCB에 저장해, 후의 해당 Process가 작업을 부여받을때 PCB의 정보를 통해서 이전 프로세스의 정보를 복원해서 진행했던 과정을 수행할 수 있다.

> 프로세스와 스레드는 컨텍스트 스위칭이 발생했을때 어떤 차이가 있을까요?
>

프로세스와 스레드에서 컨텍스트 스위칭에서 사용하는 TCB, PCB를 비교하면 TCB가 훨씬 가볍다.

이유는 스레드는 해당 프로세스 내에서 Stack을 제외한 영역 메모리를 공유하고 있기 때문에 TCB에는 Stack과 간단한 Register 포인터 정보만을 저장하기 때문에 가볍고 빠르다.

프로세스는 캐시 메모리를 초기화하고, 스레드는 초기화 하지 않는다.

이유는 프로세스의 전환은 새로운 명령어와 데이터를 로드해야하기 때문에 CPU 캐시 메모리를 초기화하지만, 컨텍스트 스위칭 같은 경우는 프로세스 내에 스레드 간에 스택과 레지스터 값 등 일부 정보만 변경되기 때문에 캐시 메모리를 초기화 하지 않는다.

이러한 캐시 메모리 초기화 비용은 무시할 수 없다.