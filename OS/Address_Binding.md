# Address Binding

프로세스의 주소는 논리적 주소와 물리적 주소로 나뉜다.

논리적 주소는 가상 주소(Virtual address)라고도 하며, CPU가 생성하는 주소이다.

프로세스마다 독립적으로 가지는 주소 공간이기 때문에 프로세스의 내부에서 사용하고, 0부터 시작한다.

물리적 주소는 프로세스가 실행되기 위해 실제로 메모리에 올라가는 위치이다.

Address Binding은 어떤 프로그램이 메모리의 어느 위치에, 즉 어떤 물리적 주소에 load 될지 결정하는 과정이다.

### Compile time

-   메모리 주소를 미리 알 고 있는 경우이다.
-   컴파일 할 때 이루어진다.
-   물리적인 메모리가 많이 비었어도, 이미 주소가 결정되어 변경할 수 없는 비효율적인 방법이다.
-   변경할 수 없으므로 컴파일된 코드를 absolute code라고 한다.

### Load time

-   컴파일 시 메모리 위치를 알 수 없는 경우이다.
-   프로그램이 실행 되었을 때 바인딩이 이루어진다. 컴파일러가 재배치 가능한 코드라 해서 relocatable code라고 한다.
-   loader에 의해 relocatable code → absolute code로 변환된다.
-   프로세스가 실행될 때마다 물리적 주소를 매핑해주는데, 바꿀때마다 매핑을 새로 하는 과정에서 시간이 오래걸린다.

### Execution time

-   실행하는 동안 주소를 결정하는 방법이다.
-   CPU가 주소를 참조할 때 마다 binding을 점거해야 한다.
    -   물리적 메모리가 바뀔 가능성이 있기 때문
-   address map 확인이 매번 필요하다.
-   하드웨어적인 지원이 필요하다(MMU)

### Logical Address vs Physical Address

-   논리적 주소는 CPU에 의해 생성된다.
-   물리적 주소는 실제 메모리 위치를 식별하는 주소이다.
-   논리적 주소와 물리적 주소는 컴파일 타임과 로드 타임때는 동일하다.
-   런타임 바인딩때 차이를 보인다.

## MMU(Memory Management Unit)

![](https://blog.kakaocdn.net/dn/d5Xk0z/btsF7Tf4F2f/wcBDyWdJk4HMIbeXhakkyk/img.png)

```
execution-time binding일때 
virtual address를 physical address로 변환해주는 하드웨어 장치이다.
```

-   사용자가 사용하는 프로그램에서는 물리적 주소가 표시되지 않는다.
-   프로그램은 논리적 주소를 다룬다.
-   논리적 주소는 사용되기 전 반드시 물리 주소로 변환되어야 한다.

## Static Linking vs Dynamic Linking

-   Static Linking
    -   컴파일 시에 필요한 모든 라이브러리와 코드를 실행 파일에 포함시키는 방식이다.
    -   컴파일러는 소스 코드를 컴파일 하여 오브젝트 파일을 생성한 후, 링커가 이러한 오브젝트 파일들을 연결하여 실행 파일을 만든다.
    -   실행 파일은 모든 함수 및 라이브러리 코드가 내장되어 있으므로, 다른 시스템에서 실행되더라도 외부 의존성은 없다.
    -   하지만 이로 인해 이식성이 떨어질 수 있고, 실행 파일의 크기가 크며 메모리 사용량을 높일 수 있다.

Source code → Compile → Object code → link → binary file → loader → Mem

-   Dynamic Linking
    -   실행 파일에 프로그램에 필요한 라이브러리 및 모듈의 위치를 포함시키지 않고, 런타임 시에 필요한 라이브러리를 로드하는 방식
    -   여러 프로그램이 같은 라이브러리를 공유할 수 있어, 메모리 공간과 디스크 공간을 절약할 수 있다.
    -   라이브러리가 업데이트되거나, 수정될 때 실행 파일을 다시 컴파일 하지 않아도 되므로, 유지 보수가 편리하다.
    -   하지만 런타임시 라이브러리를 찾고 로드하는 오버헤드가 있을 수 있다.

## Swapping

모든 프로세스를 실행하는 데 필요한 총 메모리 공간이 물리적 메모리를 초과하는 경우는 어떻게 해야할까?

메모리 크기가 다 찼을 때 프로세스를 실행하기 위해 OS는 Swapping을 사용한다.

말 그대로 swap은 두 값을 교환할 때 사용합니다.

프로세스가 실행되기 위해선 반드시 메모리에 올라가야 한다.

운영체제에서의 swap은 현재 메모리에서 잠깐 다른 저장공간으로 옮겨졌다가, 들어왔다가 이런식으로

실행에 따라 프로세스를 교체하는것입니다.

![](https://blog.kakaocdn.net/dn/nSz6T/btsF7u1V6IT/FeNAefXrFEmdBog6MFAZ3k/img.png)

예를 들어 프로세스가 가득찬 상황에서 새로운 프로세스가 실행된 경우 프로세스 하나를 잠깐 빼고, 새로 실행된 프로세스를 메모리에 올려야 합니다.

프로세스를 빼는 조건은 여러가지가 있지만, 가장 오랫동안 쓰지 않았던 프로세스(우선순위가 낮은)를 다른기억장치(보조기억장치)로 잠깐 빼두는 작업을 swap out이라고 한다.

반대로 보조기억장치에서 메모리로 다시 올려서 실행하는것을 swap in이라고 한다.

하지만 메모리 접근에 그치지 않고, Disk I/O가 발생하기 때문에 Swapping의 Context Switch는 매우 비싸다.

## Contiguous Memory Allocation

메모리를 할당하는 가장 간단한 방법중 하나는 연속 메모리 할당이다.

연속할당 방식은 프로세스를 메모리에 올릴 때 그 주소 공간을 여러개로 분할하지 않고, 물리적 메모리의 한 곳에 연속적으로 적재하는 방식이다.

연속할당 방식에는 크게 고정분할과 가변분할이 있다.

### 고정 분할 방식

-   물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고, 각 분할에 하나의 프로세스를 적재해 실행시킴

![](https://blog.kakaocdn.net/dn/dbIXJO/btsGaBksE8s/ukLv9lALbWc2WuO4otpmOK/img.png)

하지만 프로그램의 크기보다 분할의 크기가 작은 경우 분할이 비어있지만, 프로그램을 적재하지 못하는 외부 단편화가 발생한다. 이는 곧 메모리 공간의 낭비를 의미한다.

반대의 현상도 발생한다.

프로그램의 크기가 분할의 크기보다 훨씬 작은 경우 프로그램을 적재하고 메모리가 남는 현상을 내부 단편화라고 한다. 이것도 메모리 공간의 낭비를 의미한다.

### 가변 분할 방식

-   메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식이다.
-   동적으로 변하기 때문에 메모리가 낭비되는 문제가 발생하지 않는다.

![](https://blog.kakaocdn.net/dn/dbrbxm/btsF88p5wxQ/dn3clVuPAxMaO1oiSXGG4k/img.png)

어떻게 보면 가변 분할 방식은 완벽한것처럼 보인다.

왜냐하면 메모리의 낭비가 없어 보이기 때문이다.

하지만 낭비는 발생한다.

![](https://blog.kakaocdn.net/dn/bzNPVc/btsF88XVrj3/p5PTkxOWmSIe36hL999eDk/img.png)

p2와 p4가 종료되어 메모리에서 그만큼의 빈공간이 생겼다.

새로운 프로세스가 실행된다면 메모리를 어디에 적재해야할지 결정하는 문제가 생긴다. (이 문제를 동적 메모리 할당 문제라고 한다.)

여기서 OS는 동적 메모리 할당 문제를 해결하기 위해 3가지 정책을 사용한다.

### First Fit

-   프로세스의 크기 이상인 메모리 가용 공간중에서 가장 먼저 방문한곳에 프로그램을 할당하는 방법이다.

시간적으로는 효율적이지만, 메모리 공간의 효율은 그렇게 좋지 못하다.

왜냐하면 메모리 공간이 100000일때, 새로운 프로세스가 10이라면, First Fit에 의해 해당 메모리에 적재된다면 손실은 어마어마하다.

### Best Fit

-   크기가 n 이상인 가용공간 중 가장 작은 공간에 적재하는 방법이다.

메모리 공간의 효율은 좋지만, 모든 공간을 비교해야 하는 로직때문에 시간적으로 효율적이지 않다.

### Wort fit

-   가용 공간중에서 가장 크기가 큰 곳에 프로세스를 적재하는 방법

가장 크기가 큰 곳을 찾아야 하기 때문에 모든 공간을 비교해야하고, 시간적으로나, 공간적으로나 비효율적이다. 말 그대로 Worst

## Compaction

메모리 고정할당과 가변할당 모두 단편화가 발생한다.

이러한 단편화를 해결하기 위해 메모리 컴팩션의 개념이 등장했다.

```
메모리를 섞고, 빈공간은 하나의 블럭으로 만들자
```

![](https://blog.kakaocdn.net/dn/bPpnLB/btsF93By145/CpRQEPI4ngxIXLZ3Cr26Z1/img.png)

하지만 이러한 방법은 프로세스의 메모리 상의 위치를 대부분 이동시키기 때문에 비용이 많이 든다.

# 참고

[https://baebalja.tistory.com/416](https://baebalja.tistory.com/416)

[https://resilient-923.tistory.com/381](https://resilient-923.tistory.com/381)