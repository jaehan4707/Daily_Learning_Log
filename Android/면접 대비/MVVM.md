> **Q1) MVVM 패턴이란 무엇이며, 각 구성 요소의 역할을 설명해주세요.**
>

MVVM 아키텍처는 Model, View, ViewModel로 구성된 디자인 패턴으로, 각 구성 요소는 다음과 같은 역할을 합니다.

• **Model**: 데이터 소스와 비즈니스 로직을 담당합니다. 서버 API, 데이터베이스, 또는 로컬 캐시와 상호작용하여 데이터를 가져오거나 저장하며, ViewModel에서 요청받은 데이터를 제공하거나 가공합니다.

• **View**: 사용자가 보는 UI 화면으로, 사용자 이벤트를 ViewModel에 전달합니다. View는 ViewModel로부터 전달받은 데이터를 기반으로 UI를 자동으로 갱신합니다.

• **ViewModel**: View와 Model 간의 중간 역할을 합니다. Model에서 데이터를 가져오고 필요한 데이터를 가공해 View에 전달하며, 상태(state)를 관리합니다. ViewModel은 LiveData나 StateFlow와 같은 데이터 바인딩을 통해 View와 데이터를 효율적으로 연결합니다.

MVVM의 가장 큰 특징은 View와 ViewModel 간의 데이터 바인딩입니다. 이를 통해 데이터 변화가 발생하면 View가 자동으로 갱신되고, 반대로 사용자 이벤트는 ViewModel에 전달되어 비즈니스 로직이 처리됩니다. 이를 통해 코드의 의존성을 낮추고, 테스트 가능성과 유지보수성을 높일 수 있습니다.

> **Q2) MVVM에서 View와 ViewModel 사이의 데이터 바인딩을 설명해주세요. 어떤 방식으로 데이터 흐름을 처리하나요?**
>

MVVM 패턴에서 view와 ViewModel 간의 데이터 바인딩은 LiveData와 StateFlow 같은 관찰 가능한 데이터 홀더를 사용하여 이루어집니다. ViewModel은 데이터를 관리하고, View는 이 데이터를 구독 해 상태 변화에 따른 UI를 업데이트 합니다.

LiveData는 Android 생명주기를 인식하는 데이터 홀더로, View가 활성화된 상태일때만 데이터 업데이트를 수신합니다. 생명주기를 자동으로 관리해주기 때문에 메모리 누수와 같은 문제를 방지할 수 있다는 장점이 있습니다.

StateFlow는 생명주기를 직접 인식하지 않습니다. 따라서 StateFlow를 사용할 때는 생명주기를 명시적으로 관리해야 하며, repeatOnLifeCycle를 사용해 View가 활성화된 상태에서만 데이터를 구독하도록 설정할 수 있습니다.

MVVM 패턴에서 데이터 바인딩은 view와 ViewModel 간의 단방향 데이터 흐름을 보장하여 코드의 가독성과 유지보수성을 높이는 데 기여합니다. View는 ViewModel의 상태를 관찰만 하고, ViewModel은 데이터를 관리하고 가공하여 상태를 전달하는 역할만 담당합니다.

> **Q3) MVVM 패턴의 장점**
>

MVVM 패턴의 가장 큰 장점은 **데이터 바인딩을 통해 UI와 ViewModel 간의 자동 동기화**를 할 수 있다는 점입니다. 데이터 바인딩을 사용하면 LiveData나 StateFlow와 같은 관찰 가능한 데이터 홀더를 활용하여, 데이터의 변화를 자동으로 감지하고 View에 즉시 반영할 수 있습니다. 이로 인해 UI 코드의 양을 줄이고, 데이터와 UI를 연결하는 작업을 효율적으로 처리할 수 있습니다.

> **Q4) MVVM 패턴의 단점**
>

MVVM 패턴의 단점 중 하나는 복잡성입니다. 간단한 어플리케이션에서는 MVVM 패턴이 과도한 설계가 될 수 있습니다. 단방향 데이터 흐름을 유지하고 View와 ViewModel을 분리하는 데 드는 노력은 작은 프로젝트에서는 개발 시간이 길어지고, 불필요한 코드가 많아지는 결과를 초래할 수 있습니다.

추가적으로, 초기 설정에 드는 시간과 복잡성이 단점이 될 수 있으며, 때로는 간단한 구조로 빠르게 개발하는 것이 더 효율적일 수 있습니다.

> **Q5) MVVM에서 LiveData와 StateFlow를 비교하고, 각각 어떤 상황에서 사용하는 것이 더 적합한지 설명해 주세요.**
>

LiveData와 StateFlow는 모두 관찰 가능한 데이터 홀더로, UI와 데이터 간의 연결을 담당하지만 몇 가지 중요한 차이점이 있습니다. 먼저,

**생명주기 인식 여부**

- LiveData는 Android 생명주기를 인식해 STARTED 상태에서만 데이터를 전달합니다. 반면, StateFlow는 생명주기를 인식하지 않으므로, 생명주기를 명시적으로 관리하기 위해 repeatOnLifecycle 과 같은 API를 사용해야 합니다.

**초기값 필요 여부**

- LiveData는 초기값 없이 생성할 수 있지만, StateFlow는 항상 초기값을 필요로 합니다.

**코루틴 지원 여부**

- LiveData는 코루틴과 직접 통합되지 않지만, StateFlow는 Kotlin의 코루틴 기반으로 설계되어 map, filter 와 같은 연산자를 사용할 수 있어 복잡한 데이터 변환이나 비동기 작업에 적합합니다.

**성능 및 테스트 용이성**

- LiveData는 Android 종속성이 있어 테스트가 비교적 어렵지만, StateFlow는 순수 Kotlin 라이브러리로 Android에 종속되지 않아 테스트가 더 용이합니다.

결론적으로, LiveData와 StateFlow는 각자의 장단점이 있으며 프로젝트의 요구사항에 따라 적절히 선택하는 것이 중요합니다. 예를 들어 UI 상태 관리를 단순화하려면 LiveData를, 복잡한 데이터 처리나 테스트 용이성을 고려한다면 StateFlow를 선택하는 것이 더 적합합니다.

> **Q6) StateFlow를 사용할 때 View의 생명주기를 관리하는 데 주의할 점은 무엇인가요?**
>

StateFlow는 LiveData와 달리 Android 생명주기를 자동으로 인식하지 않기 때문에, View가 비활성화된 상태에서도 데이터를 계속 방출할 수 있습니다. 이를 적절히 관리하지 않으면 불필요한 리소스 사용이나 메모리 누수와 같은 문제가 발생할 수 있습니다. 따라서 StateFlow를 사용할 때는 View의 생명주기를 명시적으로 관리해야 합니다.

Android에서는 이를 해결하기 위해 repeatOnLifecycle API를 사용하는 것이 권장됩니다. 이 API는 특정 생명주기 상태(예: STARTED)에서만 Flow를 수집하도록 설정하여, View가 활성화된 동안에만 데이터를 처리하고 비활성화되면 자동으로 중지합니다.

Jetpack Compose 환경에서는 collectAsStateWithLifecycle과 같은 확장 함수를 사용해 생명주기를 고려한 안전한 데이터 수집이 가능합니다. 이 함수는 Compose의 생명주기에 맞춰 Flow의 수집을 자동으로 시작 및 중지합니다.

> **Q7) MVVM 패턴에서 단방향 데이터 흐름의 중요성은 무엇인가요?**
>

> **Q8) 양방향 데이터 바인딩은 왜 잘 사용하지 않나요?**
>

> **Q9)** **MVVM에서 데이터가 화면에 반영되는 과정을 설명해 주세요. ViewModel이 데이터를 가공하여 View에 전달하기까지의 흐름을 구체적으로 말해 보세요.**
>

> **Q10) ViewModel에서 가공해야 할 데이터가 너무 많아질 경우, 어떻게 해결하나요?**
>

> **Q11) MVVM 패턴을 사용할 때 ViewModel이 과도한 책임을 가지지 않도록 하는 방법은 무엇인가요?**
>

> **Q12) ViewModel에서 비즈니스 로직이 복잡해질 경우 이를 분리하기 위해 어떤 전략을 사용할 수 있나요?**
>

> **Q13) MVVM을 사용할 때, 데이터와 UI 간의 동기화를 유지하기 위해 발생하는 주요 문제와 이를 해결한 경험이 있나요?**
>

> **Q14) 데이터가 비동기로 갱신되는 상황에서, LiveData나 StateFlow로 UI 업데이트가 지연될 경우 어떻게 해결했나요?**
>

> **Q15) MVVM과 MVP 패턴을 비교하고, MVVM을 선택해야 할 상황과 MVP를 선택해야 할 상황을 설명해 주세요.**
>

> **Q15) MVVM과 MVP를 함께 사용한 경험이 있나요? 있다면, 어떻게 조합했나요?.**
>