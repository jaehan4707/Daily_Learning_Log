## 디자인 패턴

```
디자인 패턴은 개발하면서 발생하는 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안으로
실제 현업에서 비즈니스 요구 사항을 프로그래밍으로 처리하면서 만들어진 다양한 해결책 중에서 많은 
사람들이 인정한 모범 사례다.
디자인 패턴은 객체 지향 4대 특성(캡슐화,상속,추상화,다형성)과 설계 원칙(SOLID)을 기반으로 구현되어 있다.
```

**패턴은 알고리즘과 자주 혼동된다**.
왜냐하면 두 개념 모두 알려진 문제에 대한 일반적인 해결책을 설명하고 있기 때문이다.

- **알고리즘은 어떤 목표를 달성하기 위해 따라야 할 명확한 일련의 절차를 정의**
- **패턴은 해결책에 대한 더 상위 수준의 설명**

알고리즘은 요리법에 비유할 수 있지만 패턴은 요리법이 아닌 **청사진에 더 가깝다.**
알고리즘과 요리법 둘 다 목표를 달성하기 위한 명확한 단계들이 제시되어 있지만, 청사진은 결과와 기능들을 제시하나 구현 단계 및 순서는 사용자가 결정한다.

## 디자인 패턴의 장점

1. 재사용성 : 반복적인 문제에 대한 일반적인 해결책을 제공하므로, 이를 재사용하여 유사한 상황에서 코드를 더 쉽게 작성할 수 있다.
2. 가독성 : 일정한 구조로 정리하고 명확하게 작성하여 개발자가 코드를 이해하고 유지 보수하기 쉽게 만든다.
3. 유지 보수성 : 코드를 쉽게 모듈화 할 수 있으며, 변경이 필요한 경우 해당 모듈만 수정하여 유지보수가 쉬워진다.
4. 확장성 : 새로운 기능을 추가하거나 변경할 때 디자인 패턴을 활용하여 기존 코드를 변경하지 않고도 새로운 기능을 통합할 수 있다.
5. 안정성과 신뢰성 : 수많은 사람들이 인정한 모범 사례로 검증된 솔루션을 제공한다.

## 디자인 패턴의 단점

디자인 패턴은 소프트웨어 설계에 있어 중요한 도구이지만, 그 사용에는 몇가지 한계와 비판이 존재.

**과도한 사용의 위험**

- 디자인 패턴을 필요 이상으로 사용하면, 불필요하게 복잡해질 수 있다.
  이는 코드의 가독성과 유지 보수성을 저하시킬 수 있음.
- 모든 설계 문제에 디자인 패턴을 적용하려는 시도는 때때로 문제를 더 복잡하게 만들 수 있다.
  패턴은 특정ㅌ 문제에 대한 해결책이지만, 모든 상황에 적합한 것은 아니다.

**유연성과 성능 간의 트레이드오프**

- 일부 디자인 패턴,  특히 구조화 패턴은 추가적인 추상화 레이어를 도입한다.
  이는 유연성을 향상시키지만, 동시에 시스템 성능에 부정적인 영향을 줄 수 있다.
- 특정 패턴, 예를 들어 싱글턴이나 플라이웨이트는 성능을 최적화하는데 도움이 될 수 있지만, 잘못 사용될 경우 성능 저하를 초래할 수 있다.

**비판적 접근의 중요성**

- 디자인 패턴은 은탄환이 아니며, 모든 설계 문제에 대한 해결책이 될 수는 없다.
  각 패턴의 적용은 해당 문제의 맥락과 요구사항을 고려해 신중하게 이루어져야 한다.
- 소프트웨어 개발 분야는 지속적으로 변화하고 있기에 개발자는 지속적으로 학습하고 , 새로운 패턴을 탐색하며, 기존의 패턴을 재평가할 필요가 있다.
-

## 디자인 패턴의 종류

![image.png](https://www.hanbit.co.kr/data/editor/20220322095652_pfcyauyg.png)

디자인 패턴은 크게 생성(Creational), 구조(Structural), 그리고 행위(Behavioral) 패턴으로 분류된다.

- 생성 패턴 : 기존의 코드의 재활용과 유연성을 증가시키는 객체 생성 매커니즘들을 제공한다.
- 구조 패턴 : 구조를 유연하고 효율저그올 유지하면서 객체와 클래스를 더 큰 구조로 조합하는 방법을 설명
- 행동 패턴은 객체 간의 효과적인 의사소통과 책임 할당을 처리

### 생성 패턴(Creational Pattern)

1. 싱글톤(Singleton) : 하나의 클래스 인스턴스를 전역에서 접근 가능하게 하면서 해당 인스턴스가 한 번만 생성되도록 보장하는 패턴
2. 팩토리 메서드 (Factory Method) : 객체를 생성하기 위한 인터페이스를 정의하고, 서브 클래스에서 어떤 클래스의 인스턴스를 생성할 지 결정하는 패턴
3. 추상 팩토리(Abstract Factory) : 관련된 객체들의 집합을 생성하는 인터페이스를 제공하며, 구체적인 팩토리 클래스를 통해 객체 생성을 추상화하는 패턴
4. 빌더(Builder) : 복잡한 객체의 생성 과정을 단순화하고, 객체를 단계적으로 생성하며 구성하는 패턴
5. 프로토타입(Prototype) : 객체를 복제하여 새로운 객체를 생성하는 패턴으로 , 기존 객체를 템플릿으로 사용하는 패턴이다.

### 구조 패턴(Structural Pattern)

1. 어뎁터(Adapter) : 인터페이스 호환성을 제공하지 않는 클래스를 사용하기 위해 래퍼(Wrapper)를 제공하는 패턴
2. 브릿지(Bridge) : 추사오하와 구현을 분리하여 두 가지를 독립저그올 확장할 수 있는 패턴
3. 컴포지트(Composite) : 개별 객체와 복합 객체를 동일하게 다루어, 트리 구조의 객체를 구성하는 패턴
4. 데코레이터(Decorator) : 객체에 동적으로 새로운 기능을 추가하여 객체를 확장할 수 있는 패턴
5. 퍼사드(Facade) : 서브 시스템을 더 쉽게 사용할 수 있도록 단순한 인터페이스를 제공하는 패턴
6. 플라이웨이트 패턴(Flyweight) : 공유 가능한 객체를 통해 메모리 사용을 최적화하는 패턴
7. 프록시 패턴(Proxy) : 다른 객체에 대한 대리자(Proxy)를 제공하여 접근 제어, 지연 로딩 등을 구현하는 패턴

### 행위 패턴(Behavioral Pattern)

1. 옵저버(Observer) : 객체 간의 일대다 종속 관계를 정의하여 한 객체의 상태 변경이 다른 객체들에게 알려지도록 한다.
2. 전략(Strategy) : 알고리즘을 정의하고, 실행 중에 선택할 수 있게 한다.
3. 커맨드(Command) : 요청을 객체로 캡슐화하여 요청을 매개변수화 하고, 요청을 큐에 저장하거나 로깅하고 실행을 지연시킨다.
4. 상태(State) : 객체의 상태를 캡슐화하고, 상태 전환을 관리한다.
5. 책임 연쇄(Chain Of responsibility) : 요청을 보내는 객체와 이를 처리하는 객체를 분리하여, 다양한 처리자 중 하나가 요청을 처리한다.
6. 방문자(Visitor) : 객체 구조를 순회하면서 다양한 연산을 수행할 수 있게 한다.
7. 인터프리터(Interpreter) : 언어나 문법에 대한 해석기를 제공하여, 주어진 언어로 표현된 문제를 해결하는 패턴이다.
8. 메멘토(Memento) : 객체의 내부 상태를 저장하고 복원할 수 있는 기능을 제공하는 패턴이다.
9. 템플릿 메서드 패턴(Templater Method) : 알고리즘의 구조를 정의하면서 하위 클래스에서 각  단계의 구현을 제공하는 디자인 패턴
10. 이터레이터(Iterator) : 컬렉션 내의 요소들에 접근하는 방법을 표준화하여 컬렉션의 내부 구조에 독립적으로 접근할 수 있는 패턴

# 참고

https://ittrue.tistory.com/550

https://refactoring.guru/ko/design-patterns

https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS8616098823

https://oobwrite.com/entry/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4Design-Pattern-%EC%B4%9D%EC%A0%95%EB%A6%AC-23%EA%B0%80%EC%A7%80-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%A0%95%EC%9D%98-%EC%A2%85%EB%A5%98-%EC%9E%A5%EB%8B%A8%EC%A0%90