# Synchronization

# 동기화

<aside>
💡 다수의 프로세스가 공유 자원에 동시에 접근할 때 생기는 문제

</aside>

다수의 프로세스가 `동시`에 한 `자원을 변경`하면 치명적인 버그가 발생.

프로세스 간 동기화는 데이터 접근을 `제어`하기 위한 필수적인 기술이다.

동기화는 여러 프로세스들이 자원에 대한 접근을 순차적으로 통제하는것.(동시 접근, 변경 허용X)

**하지만 여러 프로세스의 접근을 제한하기 때문에 `병목현상`이 발생해 성능이 저하될 가능성이 높다.**

→ 이를 해결하기 위해 `임계영역`, `뮤텍스`, `세마포어`를 활용한다.

## 임계영역

<aside>
💡 스레드 간에 공유자원을 접근하는 데 있어서 문제가 발생하지 않도록 한 번에 하나의 스레드만 이용하게끔 보장해줘야 하는 영역

</aside>

임계 영역 문제를 해결하기 위해서 3가지 조건을 충족해야 한다.

1. **상호 배제(Mutual exclusion)**
    1. 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없다.
2. **진행(progress)**
    1. 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 어느 것이 들어갈지 결정해줘야 한다.
3. **한정 대기(Bounded waiting)**
    1. 다른 프로세스의 기아를 방지하기 위해, 한 번 임계 영역에 들어간 프로세스는 다음번 임계 영역에 들어갈 때 제한을 두어야 한다.

동시 접근을 해결하기 위한 방법으로 `Lock`, `Semaphore`, `monitor`가 있다.

## Lock

- 이름 그대로 걸어 잠구는 행위
- 자원을 사용하고 있는 동안에 문을 잠궈 자신 말고 아무도 못들어오게함.
- lock의 구현의 경우 bool 값을 통한 무한루프 문을 통해서 구현할 수 있다.
- Lock이 걸려있을 경우 해제해주기를 기다리는 것을 busy-waits라고 한다.

문제점

- Lock의 문제점은 특정한 상황에서 제대로 동작하지 않는 문제가 있다.

**Spinlock**

- 자신의 차례가 아닌 프로세스들이 While 문에 갇혀서 아무것도 하지 못하는 현상

## Semaphore

**Binary Semaphore**

- s가 0과 1 두 종류의 값만 가지는 경우
- 상호배제나 프로세스 동기화의 목적으로 사용
- Mutex라고 불린다.

**Counting semaphore**

- s가 0 이상의 정수 값을 가질 수 있는 경우
- Producer-Consumer 문제 등을 해결하기 위해 사용

<aside>
💡 세마포어는 단순한 변수이고 공유자원의 개수를 나타내는 변수이다.

</aside>

## Mutex

- 뮤텍스는 세마포어와 마찬가지로 병행 처리를 위한 동기화 기법 중 하나
- Mutual Exclusion으로 상호 배제라고도 한다.
- 임계 영역을 가진 스레드들의 Running Time이 서로 겹치지 않게 각각 단독으로 실행하는 기술
- `이진 세마포어`라고 부르기도 한다.
- 임계 영역에 들어갈 때 lock을 걸어 다른 프로세스가 접근하지 못하도록 하고, 임계 영역에 나와 해당 lock을 해제한다.

## 세마포어와 뮤텍스 차이

- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
- 세마포어는 소유할 수 없는 반면, 뮤텍스는 소유가 가능하며, 소유주가 이에 대한 책임을 진다.
  (뮤텍스의 경우 상태가 두개인 lock이므로, lock을 가질 수 있다)
- 현재 수행 중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다. 하지만 뮤텍스는 락을 획득한 프로세스가 반드시 그 락을 해제해야 한다.
- 세마포어는 시스템 범위에 걸쳐있고, 파일 시스템 상의 파일 형태로 존재한다. 반면 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 clean up된다.
- 세마포어는 공유 자원에 세마포어의 변수만큼 접근할 수 있다. 하지만 뮤텍스는 오직 1개만 접근할 수 있다.
- **가장 눈에 띄는 차이점은 관리하는 동기화 대상의 개수이며, 뮤텍스는 하나, 세마포어는 하나 이상이다.**

# Deadlock

<aside>
💡 다수의 프로세스나 스레드가 각자 자원을 점유하고, 다른 프로세스나 스레드가 점유한 자원을 기다리는 상황에서 발생하는 교착상태

</aside>

- 여러 개의 스레드가 서로 대기하면서 무한 루프를 형성
- 다수의 쓰레드가 같은 lock을 동시에, 다른 명령어에 의해 획득하려 할 때, 서로 절대 불가능한 일을 계속적으로 기다리는 상황
- 공유자원에 대한 동시 엑세스 문제이다.

## Deadlock이 동작하기 위한 4가지 조건

1. **상호 배제(Mutual Exclusion)**
    1. 매 순간 하나의 프로세스만이 자원을 사용할 수 있다.
2. **비선점(Non preemption)**
    1. 프로세스는 자원을 스스로 반환한다.
3. **보유 & 대기(Hold & Wait)**
    1. 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음.
4. **순환대기(Circular wait)**
    1. 자원을 기다리는 프로세스들이 순환형태로 자원 점유를 위해 대기해야 한다.

왜 3가지만 충족하면 Deadlock이 발생하지 않을까?

<aside>
💡 순환대기라는 조건때문이다.

</aside>

1. 상호 배제를 충족하지 않는다면 프로세스가 동시에 자원을 사용할 수 있으므로, 대기할 필요가 없다.
2. 점유 및 대기 조건이 없으면 자원을 요청한 프로세스는 해당 자원을 받지 못하고 실패하게 되므로 대기가 없어진다.
3. 비선점 조건을 충족하지 않는다면 다른 프로세스가 강제로 자원을 해제할 수 있으므로, 프로세스들이 서로 계속해서 자원을 해제,점유하므로 대기가 없어진다.

**따라서 세가지 조건만 충족된다면 순환 대기 조건이 없어서 Deadlock이 발생하지 않으며, 순환대기 조건이 포함된 경우 4가지 조건이 모두 충족되어야 Deadlock이 발생한다.**

# 데드락을 처리하는 방법

## Prevention

<aside>
💡 자원 할당 시 Deadlock의 4가지 필요조건 중 어느 하나가 충족하지 않도록 하는 것

</aside>

### Mutual Exclusion

- 뮤텍스를 획득하고 해제하는 순서를 정의해서 순환대기 조건을 제거
- 프로그램의 복잡성에 따라 뮤텍스 획득 및  해제 순서를 관리하는것이 어려울 수 있다.

### No Preemption

- 프로레스가 다른 자원을 wait하고 있지만 할당받지 못하는 상황에서 점유하고 있는 자원을 Release 하고 Rollback
  (즉 다른 프로세스가 들고있더라도 해당 자원을 할당받음)
- 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다.
- state를 쉽게 save하고, restore할 수 있는 자원에서 주로 사용

### Hold and wait

- 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다.
  (자원을 기다리는 상태에서 자원을 보유하고 있지 않으면 됨. 자진반납)
- 프로세스 시작 시 모든 필요한 자워 ㄴ을 할당받게 하는 방법(종료 시 모두 반납 → 매 시점마다 필요한 자원이 다른데 모든 자원을 보유하고 있는것은 비효율적)
- 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청(필요할때 할당받음)

### Circular wait

- 모든 자원 유형에 할당 순서를 정해서 정해진 순서대로만 자원을 할당
- 순서가 3인 자원 R을 보유중인 프로세스가 순서 1인 R1을 할당받기 위해서 우선 R을 반환해야 사이클이 생길 우려가 없어진다.
- 하지만 이러한 방식은 효율성과 처리량, 기아 문제가 발생할 수 있다.

---

## Avoidance

- 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당
- 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원을 할당

**은행원 알고리즘**

- 다중 프로세스 환경에서 교착상태를 방지하기 위해 사용되는 알고리즘
- 은행원 알고리즘은 각 프로세스가 `필요로 하는 자원의 최대값`과 `현재 할당된 자원의 양`을 바탕으로 안정적인 상태를 유지할 수 있는지 판단
    - 안정적인 상태를 유지할 수 있다면 자원을 할당하고 프로세스를 실행
    - 안정적인 상태를 유지할 수 없다면 자원을 할당하지 않고 대기한다.
- 교착상태가 발생했는지 여부를 판단하기 위해선 각 프로세스가 얼만큼의 자원을 요구하고, 얼마만큼의 자원을 할당받았는지를 파악해야 한다.

### Detection and recovery

- Deadlock 발생을 허용하되, 그에 대한 detection 루틴을 두어 deadlock을 발견할 경우 recover한다.

**자원할당그래프**

- 프로세스와 자원 간의 관계를 그래프로 표현한것
- 그래프 상에서 교착상태가 발생했는지 검사

- 교착상태가 발생한 경우, 교착상태를 발생시킨 프로세스나 자원을 찾아내고, 해당 프로세스나 자원을 중지시킵니다.
    - 이때 교착상태를 발생시킨 프로세스나 자원이 다른 프로세스나 자원에 의존하는 경우, 이를 모두 중지시켜야 한다.
    - 중지된 프로세스나 자원은 해당 자원을 반환하고 다른 프로세스나 자원이 사용할 수 있도록 해야한다.

- 중지된 프로세스나 자원을 다시 시작한다.
    - 이때 프로세스나 자원이 다른 프로세스나 자원에 의존하는 경우 이를 먼저 시작해야 한다.

### Ignorance

- Deadlock에 대한 책임을 시스템이 아닌 OS에게 전가

### 왜 현대 OS는 Deadlock을 처리하지 않을까?

- 빈번하게 발생하는 이벤트가 아니기 때문에 미연에 방지하기 위해 훨씬 더 많은 오버헤드를 들이는것이 비효율적이라고 판단함.
- 현대 시스템의 복잡성으로 인해 교착 상태를 완전히 방치하는것은 불가능
- 만약 시스템에서 deadlock이 발생한 경우 시스템이 비정상적으로 작동한것을 사람이 느낀 후 직접 process를 죽이는 방법으로 대처

# 식사하는 철학자

![](https://github.com/qkraudghgh/coding-interview/raw/master/OS/images/dining.png)

<aside>
💡 5명의 철학자가 앉아있고, 식탁에는 5접시의 스파게티와 5개의 포크가 놓여있다.
철학자들은 비동기적으로 먹거나 생각하는 일을 반복하는데,
스파게티를 먹기 위해서는 자신의 오른쪽과 왼쪽에 있는 포크 2개가 있어야 한다.
철학자들은 서로 대화하거나, 들고 있는 포크를 뺏을 수 없다.

</aside>

대표적인 상호배제나 동기화, 기아와 교착상태를 설명해주는 문제로,
여기서 포크는 공유자원이 되며, 철학자들의 식사를 보장해주는것이 문제의 핵심이다.

## 해결법

> 4명만 방에 들어가도록 한다. = Prevention
>
- 식사하는 인원을 4명으로 강제시킨다.

> 왼쪽 포크를 집은 다음 오른쪽 포크를 집을 수 있게하자. = **작업의 순서를 정해주자**
>
- 각자가 놓인 포크의 상황이 위치에 따라 왼쪽, 오른쪽으로 나뉘기 때문에 모든 철학자가 왼쪽 포크를 집는다면,
  오른쪽 포크를 기다리는 Deadlock에 걸릴 수 있다.

> 왼쪽 포크와 오른쪽 포크를 한번에 집을 수 있게 하자. = **Hold & Wait**
>
- 이럴 경우 Deadlock은 발생하지 않지만, 특정 철학자가 식사를 하지 못하는 기아 상태에 빠질 수 있다.

> 홀수 번호를 부여받은 철학자들은 왼쪽 포크를 집고, 오른쪽  포크를 집고,
짝수 번호를 부여 받은 철학자들은 오른쪽 포크를 집고, 왼쪽 포크를 집도록 한다.
>
- 상호 배제 보장으로 인해 두 철학자가 동시에 포크를 집는것을 허용하지 않기 때문에 식사를 할 수 있다.

<aside>
💡 하지만 이러한 방법으로 Deadlock을 해결할 수 있지만 기아는 해결할 수 없다.

</aside>

> Race Condition이 무엇인가?
>

<aside>
💡 두 개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 동작을 할 때, 공유 데이터에 대한 접근 순서에 따라 실행결과가 달라지는 상황

</aside>

> 임계구역이 무엇인지 설명하고 임계구역 문제 해결을 위한 필수 요구조건은 무엇인가?
>

<aside>
💡 임계구역은 프로세스나 스레드가 공유 자원에 접근할때, 문제가 생기지 않도록 보장해줘야하는 영역이며,
해결하기 위한 필수조건으로는
1. 상호배제 : 하나의 프로세스나 스레드만이 자원을 할당받을 수 있다.
2. 진행 : 대기하고 있는 프로세스나 스레드들의 임계영역 진입 순서를 지정해줘야한다.
3. 한정 대기 : 기아를 방지하기 위해서 자원을 할당받은 프로세스나 스레드들의 임계 영역 진입을 위한 시간 텀을 줘야 한다.

</aside>

> 임계구역 문제를 해결하기 위한 하드웨어적인 방법은 무엇인가?
>

<aside>
💡 1. Lock
2. test_and_set()
3. compare and swap

</aside>

> 세마포어가 무엇인가
>

<aside>
💡 프로세스나 스레드가 공유자원에 접근할 수 있는 수를 의미한다.
동기화 대상의 수라고 표현한다.

</aside>

> 세마포어의 단점이 무엇인가
>

<aside>
💡 spin lock이라고 하는데, 임계영역에 들어가지 못하고 프로세스들이 while문을 계속해서 도는것처럼 
대기 시간이 길어지고, 이는 CPU 효율면에서 좋지 않다.

</aside>

> 뮤텍스란?
>

<aside>
💡 이진 세마포어라고 하며, 임계영역에 진입하기전 프로세스나 스레드가 락을 걸어
다른 프로세스나 스레드가 임계영역에 진입하지 못하게 막은 뒤 
임계영역을 빠져나올때 락을 해제하는 방법으로
하나의 스레드 or 프로세스가 임계영역에 접근할 수 있도록 보장한다.

</aside>

> 뮤텍스랑 세마포어의 차이점
>

<aside>
💡 뮤텍스는 하나의 스레드나 프로세스가 임계영역에 진입할 수 있도록 lock을 통해서 구현한것이고,
세마포어는 세마포어 변수라는 범위를 통해서 해당 범위 내의 프로세스나 스레드가 임계영역에 진입할 수 있다.
즉 차이점은 임계 영역에 접근할 수 있도록 허락한 스레드나 프로세스의 개수이다.

</aside>

> lock을 얻기 위해 대기하는 프로세스들은 spin lock 기법을 사용할 수 있는데 이 방법의 장단점은 무엇이고, 단점을 해결할 수 있는 방법은 무엇인가?
>

<aside>
💡 장점으론 구현하기 간단하다는 점이다.
그리고 다른 프로세스나 스레드가 락을 해제할때까지 기다려야하므로 대기시간을 예측하기 쉽고, Context Switching이 일어나지 않는다.
하지만 단점으로는 대기하는 동안 lock을 확인해야하는 while문을 계속해서 돌 기 때문에 CPU를 낭비한다는점이다.

해결방법은 대기하는 동안 사용하는 CPU 리소스를 다른 쓰레드에게 양보한다.

</aside>

> 뮤텍스와 세마포어 모두 커널이 관리하기 때문에 Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야하는데 이 방법의 장단점은 무엇이고 ,단점을 해결할 수 있는 방법
>

<aside>
💡 뮤텍스와 세마포어는 모두 커널이 관리하기 때문에 안전하고 신뢰할 수 있다.
하지만 단점으로는 시스템 콜을 계속해서 호출하기 때문에 오버헤드가 발생할 수 있다.
시스템 호출을 할 경우 컨텍스트 스위칭이 발생하고, 이로 인한 비용이 발생한다.
이를 해결하기 위한 방법으로는 race condtion을 최대한 줄이는것이 바람직하지만, 현실적이지 않기 때문에 Context switching을 사용하지 않는 Spin lock을 사용해서 동기화를 수행하는것도 하나의 방법이다.

</aside>

> Deadlock이란?
>

<aside>
💡 프로세스나 스레드가 각자 자원을 점유하고 있는 상황에서 다른 프로세스나 스레드가 점유하고 있는 자원을 기다리고 있는 상황으로 필연적으로 계속적으로 대기할 수 밖에 없는 교착상태이다.

</aside>

> Deadlock의 발생조건
>

<aside>
💡 1. 상호배제 : 하나의 프로세스만이 자원을 할당받을 수 있다.
2. 비선점 : 프로세스는 본인스스로 자원을 해제하지, 강제로 해제당할 수 없다.
3. 자원 보유와 대기 : 자원을 보유하고있는 프로세스가 기다리는 상황에서 가지고 있는 자원을 반환하지 않고 보유한다.
4. 선형대기 : 자원을 기다리고 있는 프로세스들이 순환형태로 대기하고 있다.

</aside>

> Deadlock을 해결할 수 있는 방법
>

<aside>
💡 1. Prevention
2. Avoidance
3. detection and recover
4. Igonorance

</aside>

> 자원 할당 그래프 알고리즘에 대해서 설명해봐라
>

<aside>
💡 프로세스와 자원간의 관계를 그래프 형태로 표현한것으로 각각의 정점은 프로세스와 자원을 의미하고, 각 Edge는 프로세스가 자원에게 보내는 요청과 자원이 할당된 정보를 의미한다.
그래프 내에서 Cycle이 존재하지 않는다면 Deadlock은 발생하지 않지만 
Cycle이 존재하면 Deadlock이 발생하는 가능성이 있다.
해당 가능성은 맞물려있는 자원이 하나일경우 Deadlock이 발생한다.

</aside>

> 은행원 알고리즘에 대해 설명해봐라
>

<aside>
💡 데드락 회피에 대한 방법으로,
프로세스들이 최대로 할당받을 수 있는 자원의 양과 이미 할당받은 자원의 양을 바탕으로
데드락이 일어날수있는지에 대한 여부를 판단해서
데드락이 일어난다면 자원 할당을 포기하고, 데드락이 일어나지 않는다면 자원 할당을 해준다.

</aside>